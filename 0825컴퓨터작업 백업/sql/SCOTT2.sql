--1
SELECT * 
FROM EMP;
WHERE SAL >= 100 AND SAL <= 2000; --SAL BETWEEN 1000 AND 2000;

--2 사원 이름의 첫3자 출력
SELECT SUBSTR(ENAME,1,3) --1글자부터 3글자까지
FROM EMP;

--2-1 1,2,3 제외하고 4,5,6글자 출력/??
SELECT SUBSTR(EANME,4,6)
FROM EMP;

--3
SELECT JOB,
      SUBSTR(JOB, -LENGTH(JOB)),
      SUBSTR(JOB, -LENGTH(JOB),2),
      SUBSTR(JOB, -3)             --'-'가 붙으면 뒤에서부터.
FROM EMP;

--3-1
SELECT JOB,
      SUBSTR(JOB, LENGTH(JOB)),
      SUBSTR(JOB, -LENGTH(JOB)),
      SUBSTR(JOB, -LENGTH(JOB),2),
      SUBSTR(JOB, -3)             
FROM EMP;

--5
SELECT INSTR('HELLO, ORACLE!', 'L') AS INSTR_1,       --AS뒤에는 제목(별칭)
                                                      --L을 찾아라
       INSTR('HELLO, ORACLE!', 'L', 5) AS INSTR_2,    --5번째 글자 이후부터 L을 찾아라
       INSTR('HELLO, ORACLE!', 'L', 2, 2) AS INSTR_3  --2번째 글자이후에 L중 2번째 L 
FROM DUAL;

--6 사원 이름에 S가 들어있는 이름
SELECT *
FROM EMP
WHERE INSTR(ENAME, 'S')>0;      --ENAME LIKE '%S%';

--6-1
SELECT INSTR(ENAME, 'S')
FROM EMP;

--7
SELECT '010-1234-5678' AS REPLACE_BEFORE,                 --REPLACE 기능
      REPLACE('010-1234-5678', '-', ' ') AS REPLACE_1,    --'-'가 공백으로 바뀜
      REPLACE('010-1234-5678', '-') AS REPLACE_2          --'-'가 없어짐
FROM DUAL;

--8
SELECT 'ORACLE',
        LPAD('ORACLE', 10, '#') AS LPAD_1,
        RPAD('ORACLE', 10, '*') AS RPAD_1,
        LPAD('ORACLE', 10) AS LPAD_2,
        RPAD('ORACLE', 10) AS RPAD_2
  FROM DUAL;

--9 사원 이름에서 앞의 3자리만 뽑고 전체 10자리로 오른쪽은 *로 채우기
SELECT RPAD(SUBSTR(ENAME,1,3),10,'*')
FROM EMP;

--10  971225-문자열을 14칸에 적되 오른쪽은 *로
SELECT RPAD('971225-',14,'*') AS RPAD_JMNO
FROM DUAL;

--11 CONCAT
SELECT CONCAT('ABC','DEF')
FROM DUAL;

--12 사원번호:사원명
SELECT COMCAT(COMCAT(ENPNO,':'),ENAME)
FROM EMP;

--12-1 다른방법
SELECT EMPNO || ':' || ENAME
FROM EMP;

--13
SELECT '[' || TRIM('- -Oracle- -')||']' AS TRIM,
'[' || TRIM(LEADING FROM'- -Oracle- -')||']' AS TRIM_LEADING,
'[' || TRIM(TRAILING FROM'- -Oracle- -')||']' AS TRIM_TRAILING,
'[' || TRIM('- -Oracle- -')||']' AS TRIM_BOTH
 FROM DUAL;
 
--14
SELECT '[' || TRIM('-Oracle-')||']' AS TRIM,
'[' || LTRIM('-Oracle-')||']' AS LTRIM,
'[' || LTRIM('<-Oracle->','-<')||']' AS LTRIM_2,
'[' || RTRIM('-Oracle-')||']' AS RTRIM,
'[' || RTRIM('<-Oracle->','>-')||']' AS RTRIM_2
 FROM DUAL;
 
 ==================6/2 앞부분은 scott1에.
 --01 연봉이 2000에서 3000
SELECT ENAME
FROM EMP
WHERE SAL BETWEEN 2000 AND 3000;

--02-1
SELECT SAL,COMM,SAL*12+NVL(COMM,0) AS "연봉"
FROM EMP;

--02-2
SELECT SAL,COMM,NVL2(COMM,SAL*12+COMM,SAL*12) AS "연봉"
FROM EMP;

--03
SELECT EMPNO,ENAME,JOB,SAL,
DECODE(JOB,
          'MANEGER',SAL*1.1,
          'SALESMAN',SAL*1.05,
          'ANALYST',SAL,
          SAL*1.03)AS UPSAL
FROM EMP;

--04
SELECT EMPNO,ENAME,JOB,SAL
CASE JOB
WHEN 'MANAGER' THEN SAL*1.1
WHEN 'SALESMAN' THEN SAL*1.05
WHEN 'ANALYST' THEN SAL
ELSE SAL*1.03
END AS UPSAL
FROM EMP;
--JOB에 따라 WHEN이 달라짐

--05
SELECT EMPNO,ENAME, COMM,
CASE
WHEN COMM IS NULL THEN '해당사항 없음'
WHEN COMM =0 THEN '수당없음'
WHEN COMM >0 THEN '수당:'||COMM
END AS COMM_TEXT
FROM EMP;

--5-2 5-1을 안보고 써보기
SELECT EMPNO,ENAME,COMM
CASE
WHEN COMM IS NULL THEN '해당사항 없음'
WHEN COMM =0 THEN '수당없음'
WHEN COMM>0 THEN ||'수당: '
END AS 
FROM EMP;


--6장 연습문제
--Q1
--SUSTR(속성 또는 문자열,시작,갯수)-문자열 일부분 추출
--RPAD(속성 또는 문자열,전체 자리수,'채울문자')-채우기
--LENGTH()-길이

SELECT EMPNO,
       RPAD(SUBSTR(EMPNO,1,2),4,'*')AS MASKING_EMPNO,
       ENAME,
       RPAD(SUBSTR(ENAME,1,1),LENGTH(ENAME),'*')AS MASKING_ENAME
FROM EMP
WHERE LENGTH(ENAME)=5;

--Q2
SELECT EMPNO,ENAME,SAL,
       TRUNC(SAL/21.5,2)AS DAY_PAY,
      ROUND(SAL/21.5/8,1)AS TIME_PAY
FROM EMP;

--Q3
SELECT EMPNO,ENAME,HIREDATE,
  TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE,3),'월'),'YYYY-MM-DD'),
  NVL(TO_CHAR(COMM),'N/A')AS COMM
FROM EMP;

--Q4
--SUBSTR()
SELECT EMPNO,ENAME,MGR,
  CASE
  WHEN MGR IS NULL THEN '0000'
  WHEN SUBSTR(MGR,1,2)='78' THEN'8888'
  WHEN SUBSTR(MGR,1,2)='77'THEN'7777'
  WHEN SUBSTR(MGR,1,2)='76'THEN'6666'
  WHEN SUBSTR(MGR,1,2)='75'THEN'5555'
  ELSE TO_CHAR(MGR)
 END AS CHG_MGR
FROM EMP;

------------------7장-------------------
--7-01 각 함수 이용하여 급여 합계, 수, 최대, 최소, 평균 구하기
SELECT SUM(SAL),COUNT(SAL),MAX(SAL),MIN(SAL),AVG(SAL)
FROM EMP;

--7-02 사원수 구하기
SELECT COUNT(*)
FROM EMP;

--7-02-2 사원수 구하기

SELECT COUNT(ENAME)
FROM EMP;

--7-02-3 추가수당 받는 수
SELECT COUNT(COMM)
FROM EMP;

--7-03 부서 목록
SELECT * FROM DEPT;

--7-03-2  부서의 수
SELECT COUNT(*)
FROM DEPT;

--7-04보너스 없는 사원의 수
SELECT COUNT(*)
FROM EMP
WHERE COMM IS NULL;

--7-05 10번 부서의 사원 수
--()안에 DEPTNO보다 *가 제일 안정적
SELECT COUNT(*)
FROM EMP
WHERE DEPTNO=10;

--7-6 각 부서별 사원수
SELECT DEPTNO,COUNT(*)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
--ORDER BY는 제일 마지막에. DEPTNO를 정렬한다.

--7-7 각 부서별 최고 봉급
SELECT DEPTNO, MAX(SAL)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

--7-8 각 부서별 최장기간 근무한 사람의 입사일
SELECT DEPTNO, MIN(HIREDATE)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
--최장기간이니 MIN을 써야한다.

--7-9 부서번호 목록
SELECT DEPTNO
FROM EMP;

--7-10 부서번호 목록(중복제외)
SELECT DISTINCT DEPTNO
FROM EMP;
--중복 삭제

--7-11 급여 합계
SELECT SUM(SAL),SUM(ALL SAL),SUM(DISTINCT SAL)
FROM EMP;

--7-12 입사일 출력 단, 중복제거
SELECT DISTINCT HIREDATE
FROM EMP;

--7-13 30번 부서의 사원수
SELECT COUNT(*)
FROM EMP
WHERE DEPTNO=30;

--7-14 10번 부서의 최고 봉급액
SELECT MAX(SAL)
FROM EMP
WHERE DEPTNO=10;

--7-15 10번 부서의 최저 봉급액
SELECT MIN(SAL)
FROM EMP
WHERE DEPTNO=10;

--7-16 20번 부서의 최근 입사자의 입사일
SELECT MAX(HIREDATE)
FROM EMP
WHERE DEPTNO=20;

--7-17 20번 부서의 최고 장기간 근무한 사람의 입사입
SELECT MIN(HIREDATE)
FROM EMP
WHERE DEPTNO=20;

--7-18 30번 부서의 평균 봉급
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO=30;

--7-19 30번 부서의 평균 봉금(단, 봉급의 중복은 제거 후 평균)
SELECT AVG(DISTINCT SAL)
FROM EMP
WHERE DEPTNO=30;

--7-20 각 부서의 급여 평균
SELECT ROUND(AVG(SAL)), '10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL 
SELECT ROUND(AVG(SAL)), '20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT ROUND(AVG(SAL)), '30' AS DEPTNO FROM EMP WHERE DEPTNO = 30;

--7-21 부서번호, 직급별 평균 봉급
SELECT DEPTNO,JOB,AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

--7-22 부서와 직급별로 평균 봉급이 2000이상인 사람들의 부서번호, 직급, 평균 봉급 순으로 출력
SELECT DEPTNO,JOB,AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;

--7-23 7-22의 오류 예시
SELECT DEPTNO,JOB,AVG(SAL)
FROM EMP
WHERE AVG(SAL) >= 2000
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;
--WHERE절은 그룹함수를 쓸 수 없다. 비교함수에 쓰인다.
--따라서 그룹함수는 WHERE절이 아닌 HAVING

--7-24 봉급이 3000이하인 사원들을 대상으로 부서, 직급별 평균봉급이 2000이상
SELECT DEPTNO,JOB,AVG(SAL)
FROM EMP
WHERE SAL <= 3000
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;

--7-25 부서, 직급별 사원수, 최대 봉급, 봉급 합계, 평균 봉급 출력
SELECT DEPTNO,JOB,COUNT(*),MAX(SAL),SUM(SAL),AVG(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO,JOB)
ORDER BY DEPTNO, JOB;

--7-26 부서, 직급별 사원수, 최대 봉급, 봉급 합계, 평균 봉급 출력
SELECT DEPTNO,JOB,COUNT(*),MAX(SAL),SUM(SAL),AVG(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO,JOB)
ORDER BY DEPTNO, JOB;

--7-27 부서, 직급별 사원수 출력
SELECT DEPTNO,JOB,COUNT(*)
FROM EMP
GROUP BY ROLLUP(DEPTNO,JOB)
ORDER BY DEPTNO, JOB;

--7-28 부서, 직급별 사원수 출력
SELECT DEPTNO,JOB,COUNT(*)
FROM EMP
GROUP BY JOB,ROLLUP(DEPTNO);

--7-29 부서, 직급별 사원수 출력
SELECT DEPTNO,JOB,COUNT(*)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO,JOB)
ORDER BY DEPTNO, JOB;

--7-30 부서번호, 직급별 사원수 출력
SELECT DEPTNO,JOB,COUNT(*)
FROM EMP
GROUP BY ROLLUP(JOB, DEPTNO);

--7-31 부서번호, 직급별 사원수 출력
SELECT DEPTNO,JOB,COUNT(*)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO,JOB)
ORDER BY DEPTNO,JOB;

--7-32 cube 함수를 적용한 그룹화
SELECT DEPTNO,JOB,COUNT(*),MAX(SAL),SUM(SAL),AVG(SAL),
GROUPING(DEPTNO),
GROUPING(JOB)
FROM EMP
GROUP BY CUBE(DEPTNO,JOB)
ORDER BY DEPTNO,JOB;

--7-33 부서번호와 직급별 사원수, 최대 연봉, 연봉의 합, 평균연봉을 cube 함수를 적용한 그룹화
SELECT DECODE(GROUPING(DEPTNO),1,'ALL_DEPT',DEPTNO)AS DEPTNO,
DECODE(GROUPING(JOB),1,'ALL_JOB',JOB)AS JOB,
COUNT(*), MAX(SAL),SUM(SAL),AVG(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO,JOB)
ORDER BY DEPTNO,JOB;
--GROUPING 된 것은 0(아니면 1)

--===========================6/9======

--1 갯수 세기-COUNT()
SELECT COUNT(*)
FROM EMP;

--2 사원명, 봉급의 합계 구하기
SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO;

--2(1)
--SELECT ENAME, SUM(SAL)
--FROM EMP;     는 안됨

--7-1 SUM 함수를 사용하여 급여 합계 출력하기
SELECT SUM(SAL)
FROM EMP;

--7-2 SUM 함수를 사용하여 사원 이름과 급여 합계 출력하기
SELECT ENAME, SUM(SAL)
FROM EMP;

--7-3 추가 수당 합계 구하기
SELECT SUM(COMM)
FROM EMP;

--7-4 급여 합계 구하기(DISTINCT, ALL사용)
SELECT SUM(DISTINCT SAL),
       SUM(ALL SAL),
       SUM(SAL)
FROM EMP;

--7-5 EMP 테이블의 데이터 개수 출력하기
SELECT COUNT(*)
FROM EMP;

--3 부서번호 출력
SELECT DEPTNO
FROM EMP;

--4 사원들이 속한 부서의 수
SELECT COUNT(DISTINCT DEPTNO)
FROM EMP;

--5 DISTINT:중복제거. 중복을 제거해 합계 구하기
SELECT COUNT(DISTINCT SAL),
SUM(ALL SAL),
SUM(SAL)
FROM EMP;

--6 사원들의 정보
SELECT *
FROM EMP;

--7 사원들의 수(행의 수)
SELECT COUNT(*)
FROM EMP;

--8(7-6) 30번 부서의 사원 수
SELECT COUNT(*)
FROM EMP
WHERE DEPTNO = 30;

--9(7-7)COUNT 함수 사용해 급여 개수 구하기(ALL은 하나마나.)
SELECT COUNT(DISTINCT SAL),
       COUNT(ALL SAL),
       COUNT(SAL)
FROM EMP;

--10(7-8) 보너스가 정해진 사람들의 수
SELECT COUNT(COMM)
FROM EMP;

--11 보너스 받는 사람 수
SELECT COUNT(COMM)
FROM EMP
WHERE COMM >0;

--12(7-9) 보너스가 NULL이 아닌 사람, 즉 정해진 사람의 수
--COMM과 * 둘 다 상관 없음
SELECT COUNT(COMM)
FROM EMP
WHERE COMM IS NOT NULL;

--13(7-10) 최고 봉급액
SELECT MAX(SAL)
FROM EMP;

--14(7-10) 10번 부서의 최고 봉급액(MAX)
SELECT MAX(SAL)
FROM EMP
WHERE DEPTNO = 10;

--15(7-11) 10번 부서의 최저 봉급액(MIN)
SELECT MIN(SAL)
FROM EMP
WHERE DEPTNO = 10;

--16 10번 부서의 평균 봉급액(AVG)
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO = 10;

--17 최근 입사일
SELECT MAX(HIREDATE)
FROM EMP;

--18 가장 먼저 입사한 사원의 입사일
SELECT MIN(HIREDATE)
FROM EMP;

--19(7-13) 20번 부서에서 최고참의 입사일
SELECT MIN(HIREDATE)
FROM EMP
WHERE DEPTNO = 20;

--7-12 20번 부서에서 신참의 입사일
SELECT MAX(HIREDATE)
FROM EMP
WHERE DEPTNO = 20;

--20(7-14) 30번 부서의 평균 봉급액
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO = 30;

--7-15 DISTINCT로 중복을 제거한 급여 열의 평균 급여 구하기
SELECT AVG(DISTINCT SAL)
FROM EMP
WHERE DEPTNO = 30;

--21(7-16) 10번부서,20번 부서, 30번 부서의 평균 봉급액 구하기(UNION ALL)
SELECT AVG(SAL),'10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL),'20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL),'30' AS DEPTNO FROM EMP WHERE DEPTNO = 30;

--21-1 21번 문제에 소수점 자르고 이름을 AVG_SAL로 하기
SELECT TRUNC(AVG(SAL)) AS AVG_SAL,'10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT TRUNC(AVG(SAL)) AS AVG_SAL,'20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT TRUNC(AVG(SAL)) AS AVG_SAL,'30' AS DEPTNO FROM EMP WHERE DEPTNO = 30;

--7-17 GROUP BY를 사용하여 평균 급여 출력하기
SELECT AVG(SAL), DEPTNO
FROM EMP
GROUP BY DEPTNO;

--22(7-18) 부서 및 직급별 평균 봉급
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

--7-19 GROUP BY 절에 없는 열을 SELECT절에 포함했을 경우
SELECT ENAME, DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO;

--23(7-20) 부서 및 직급별 평균 봉급을 구하는 데 봉급 평균이 2000이상인 정보만
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP 
GROUP BY DEPTNO,JOB
HAVING AVG(SAL)>=2000
ORDER BY DEPTNO, JOB;
--HAVING 대신 WHERE 쓰면 안됨. 모아서 2000이상인 사람

--23-1(7-21) 다른 방법(WHERE쓰려면 이렇게). 2000이상을 모은 사람(의미와 위치 좀 다름)
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP 
WHERE SAL>=2000
GROUP BY DEPTNO,JOB
ORDER BY DEPTNO, JOB;

--24(7-23) 봉급이 3000이하인 사람들 대상 부서별, 직급별 평균 봉급이 2000이상
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
WHERE SAL <= 3000
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO,JOB;

--25(7-24) 부서별 직급별, 사원수, 최대 봉급, 봉급액 합계, 평균 봉급 부서별 직급별 정렬
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

--26(7-25) 25번과 동일 + ROLLUP(DEPTNO,JOB)요약
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

--27(7-26) CUBE
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--27-1 27번에 봉급 반올림하기
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), ROUND(AVG(SAL))
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--28 ROLLUP을 JOB에 대해서만 부서, 직급별 인원수
--7-27 DEPTNO를 먼저 그룹화한 후 ROLLUP함수에 JOB 지정하기
SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY DEPTNO, ROLLUP(JOB);

--29(7-28) 순서를 바꿔 JOB을 먼저 그룹화 한 후 ROLLUP함수에 DEPTNO 지정하기
SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY JOB, ROLLUP(DEPTNO);

--30(7-29) GROUPING SETS 함수를 사용하여 열별로 그룹으로 묶어 출력하기
--지정한 모든 열을 대그룹으로 처리해서 출력
SELECT DEPTNO, JOB, COUNT(*)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--31 GROUPING 함수
--7-30 DEPTNO,JOB열의 그룹화 결과 여부를 GROUPING 함수로 확인하기
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL),
  GROUPING(DEPTNO),
  GROUPING(JOB)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--32(7-31) DECODE문으로 GROUPING함수를 적용하여 결과 표기하기
SELECT DECODE(GROUPING(DEPTNO),1,'ALL_DEPT',DEPTNO)AS DEPTNO,
      DECODE(GROUPING(JOB),1,'ALL_JOB',JOB)AS JOB,
      COUNT(*),MAX(SAL),SUM(SAL), AVG(SAL)
      FROM EMP
      GROUP BY CUBE(DEPTNO,JOB)
      ORDER BY DEPTNO, JOB;
      
--33 (7-32) DEPTNO, JOB을 함께 명시한 GROUPING_ID 함수 사용하기
SELECT DEPTNO, JOB, COUNT(*),SUM(SAL),
  GROUPING(DEPTNO),
  GROUPING(JOB),
  GROUPING_ID(DEPTNO,JOB)
  FROM EMP
  GROUP BY CUBE(DEPTNO,JOB)
  ORDER BY DEPTNO,JOB;
  
--7-33 GROUP BY절로 그룹화 하여 부서 번호와 사원 이름 출력하기
SELECT DEPTNO,ENAME
  FROM EMP
GROUP BY DEPTNO,ENAME;

--34(7-34) 부서별 사원 이름을 나란히 나열하여 출력하기
SELECT DEPTNO,  
    LISTAGG(ENAME,',')
    WITHIN GROUP(ORDER BY SAL DESC)AS ENAMES
    FROM EMP
  GROUP BY DEPTNO;
  
--34-2 봉급 적은 순(ASC)(봉급 많은 순은 DESC)
 SELECT DEPTNO,  
    LISTAGG(ENAME,',')
    WITHIN GROUP(ORDER BY HIREDATE ASC)AS ENAMES
    FROM EMP
  GROUP BY DEPTNO;

--35(7-35) 부서별,직책별로 그룹화하여 최고 급여 데이터를 출력하기
SELECT DEPTNO, JOB, MAX(SAL)
  FROM EMP
  GROUP BY DEPTNO, JOB
  ORDER BY DEPTNO, JOB;
  
--36(7-36) PIVOT 함수를 하용하여 직책별,부서별 최고 급여를 2차원 표 형태로 출력하기
SELECT *
FROM(SELECT DEPTNO,JOB,SAL FROM EMP)
PIVOT(MAX(SAL) FOR DEPTNO IN (10,20,30))
ORDER BY JOB;

--36-1 MIN
SELECT *
FROM(SELECT DEPTNO,JOB,SAL FROM EMP)
PIVOT(MIN(SAL) FOR DEPTNO IN (10,20,30))
ORDER BY JOB;

--36-2 AVG
SELECT *
FROM(SELECT DEPTNO,JOB,SAL FROM EMP)
PIVOT(AVG(SAL) FOR DEPTNO IN (10,20,30))
ORDER BY JOB;

--36-3 SUM
SELECT *
FROM(SELECT DEPTNO,JOB,SAL FROM EMP)
PIVOT(SUM(SAL) FOR DEPTNO IN (10,20,30))
ORDER BY JOB;

--37(7-37) PIVOT 함수를 사용하여 부서별, 직책별 최고 급여를 2차원 표 형태로 출력하기
SELECT *
  FROM(SELECT JOB, DEPTNO, SAL FROM EMP)
PIVOT(MAX(SAL)
  FOR JOB IN ('CLERK' AS CLERK,
              'SALESMAN' AS SALESMAN,
              'PRESIDENT' AS PRESIDENT,
              'MANAGER' AS MANAGER,
              'ANALYST' AS ANALYST)
              )
              ORDER BY DEPTNO;
              
--37-1 MIN
SELECT *
  FROM(SELECT JOB, DEPTNO, SAL FROM EMP)
PIVOT(MIN(SAL)
  FOR JOB IN ('CLERK' AS CLERK,
              'SALESMAN' AS SALESMAN,
              'PRESIDENT' AS PRESIDENT,
              'MANAGER' AS MANAGER,
              'ANALYST' AS ANALYST)
              )
              ORDER BY DEPTNO;
              
--37-2 AVG
SELECT *
  FROM(SELECT JOB, DEPTNO, SAL FROM EMP)
PIVOT(AVG(SAL)
  FOR JOB IN ('CLERK' AS CLERK,
              'SALESMAN' AS SALESMAN,
              'PRESIDENT' AS PRESIDENT,
              'MANAGER' AS MANAGER,
              'ANALYST' AS ANALYST)
              )
              ORDER BY DEPTNO;
              
--37-3 SUM
SELECT *
  FROM(SELECT JOB, DEPTNO, SAL FROM EMP)
PIVOT(SUM(SAL)
  FOR JOB IN ('CLERK' AS CLERK,
              'SALESMAN' AS SALESMAN,
              'PRESIDENT' AS PRESIDENT,
              'MANAGER' AS MANAGER,
              'ANALYST' AS ANALYST)
              )
              ORDER BY DEPTNO;
              
--38(7-38) DECODE문을 활용하여 PIVOT함수와 같은 출력 구현하기
SELECT DEPTNO,
  MAX(DECODE(JOB,'CELRK',SAL)) AS "CELRK",
  MAX(DECODE(JOB,'SALESMAN',SAL)) AS "SALESMAN", 
  MAX(DECODE(JOB,'PRESIDENT',SAL)) AS "PRESIDENT",
  MAX(DECODE(JOB,'MANAGER',SAL)) AS "MANAGER",
  MAX(DECODE(JOB,'ANALYST',SAL)) AS "ANALYST"
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

--39(7-39) UNPIVOT 함수를 사용하여 열로 구분된 그룹을 행으로 출력하기
SELECT *
FROM(SELECT DEPTNO,
  MAX(DECODE(JOB,'CLERK',SAL)) AS "CLERK",
  MAX(DECODE(JOB,'SALESMAN',SAL)) AS "SALESMAN", 
  MAX(DECODE(JOB,'PRESIDENT',SAL)) AS "PRESIDENT",
  MAX(DECODE(JOB,'MANAGER',SAL)) AS "MANAGER",
  MAX(DECODE(JOB,'ANALYST',SAL)) AS "ANALYST"
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO)
UNPIVOT(
SAL FOR JOB IN (CLERK, SALESMAN, PRESIDENT, MANAGER, ANALYST))
ORDER BY DEPTNO, JOB;

--Q1
SELECT DEPTNO,
  TRUNC(AVG(SAL))AS AVG_SAL,
  MAX(SAL)AS MAX_SAL,
  MIN(SAL)AS MIN_SAL,
  COUNT(*)AS CNT
FROM EMP
GROUP BY DEPTNO;

--Q2
SELECT JOB,COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(*) >= 3;

--Q3
SELECT TO_CHAR(HIREDATE,'YYYY')AS HIRE_YEAR,
DEPTNO,
COUNT(*) AS CNT
FROM EMP
GROUP BY TO_CHAR(HIREDATE,'YYYY'),DEPTNO;

--Q4
SELECT NVL2(COMM,'O','X')AS EXIST_COMM,
      COUNT(*) AS CNT
      FROM EMP
      GROUP BY NVL2(COMM,'O','X');

--Q5
SELECT DEPTNO,
  TO_CHAR(HIREDATE, 'YYYY')AS HIRE_YEAR,
  COUNT(*) AS CNT,
  MAX(SAL) AS MAX_SAL,
  SUM(SAL) AS SUM_SAL,
  AVG(SAL) AS AVG_SAL
FROM EMP
GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY'));


-----------====6/16====----------------
--8 여러 테이블을 하나의 테이블처럼 사용하는 조인

--1 모든 사람의 월급
SELECT ENAME,SAL
FROM EMP;

--2
SELECT *
FROM EMP;
--==%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%==--
--EMPNO:사원번호, ENAME:사원명, JOB:직급, MGR:관리자번호
--HIREDATE:입사일, SAL:봉급, COMM:보너스, DEPTNO:부서번호
--==%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%==--

--2-1 이름과 부서번호
SELECT ENAME, DEPTNO
FROM EMP;

--3 10번 부서 사원명과 부서번호
SELECT ENAME, DEPTNO
FROM EMP
WHERE DEPTNO = 10;

--4 20번,30번 부서의 사원명,부서번호,봉급
SELECT ENAME, DEPTNO
FROM EMP
WHERE DEPTNO = 20 OR DEPTNO = 30;

--4-1 다른 방법
SELECT ENAME, DEPTNO
FROM EMP
WHERE DEPTNO IN(20,30);

--5 입사일이 1981년인 사원들의 사원명과 입사일, 관리자 번호
SELECT ENAME, HIREDATE, MGR
FROM EMP
WHERE TO_CHAR(HIREDATE,'YYYY') = '1981';

--5-1 다른방법1
SELECT ENAME, HIREDATE, MGR
FROM EMP
WHERE HIREDATE LIKE '81%';

--5-2 다른방법2
SELECT ENAME, HIREDATE, MGR
FROM EMP
WHERE HIREDATE >= '1981/01/01' AND HIREDATE <= '1981/12/31';

--6 DEPT 테이블 확인
SELECT *
FROM DEPT;
--==%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%==--
--DEPTNO:부서번호, DNAME:부서명, LOC:부서위치
--==%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%==--

--7 SALGRADE 테이블
SELECT * FROM SALGRADE;
--==%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%==--
--GRADE:등급, LOSAL:최하위 급여, HISAL:최고 급여
--==%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%==--

--8 20번 부서의 부서번호, 부서명
SELECT *
FROM DEPT
WHERE DEPTNO = 20;

--9 등급이 1등급 중 최하위 급여와 최고 급여
SELECT * 
FROM SALGRADE
WHERE GRADE = 1;

--10 봉급이 3000대인 사원들의 사원명과 급여
SELECT ENAME, SAL
FROM EMP
WHERE SAL >= 3000 AND SAL < 4000;

--11 부서명이 SALES인 부서의 위치(LOC)출력
SELECT LOC 
FROM DEPT
WHERE DNAME = 'SALES';

--12 10번 부서의 위치
SELECT LOC
FROM DEPT
WHERE DEPTNO = 10;

--13 10번 부서의 사원명과 부서번호
SELECT ENAME, DEPTNO
FROM EMP
WHERE DEPTNO = 10;

--14 10번 부서의 사원명과 부서번호, 부서명
-- 테이블이 다르니 2개 필요하다.
--"column ambiguously defined" DEPTNO는 두 테이블에 있다. 소속을 밝혀줘야한다.
-- EMP.DEPTNO처럼
SELECT ENAME, EMP.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND EMP.DEPTNO = 10;
--AND DEPT.DEPTNO = 10;써도 된다.

--15 사원수 --14개
SELECT COUNT(*)
FROM EMP;

--16 부서수 --4개
SELECT COUNT(*) 
FROM DEPT;

--17 10번 부서에 속한 사원번호, 봉급, 부서명, 부서위치
SELECT EMP.DEPTNO, SAL, DNAME, LOC
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND EMP.DEPTNO = 10;

--18-1 18번 전 설명
SELECT *
FROM SALGRADE;
--GRADE, LOSAL, HISAL

--18 사원번호, 사원명, 봉급, 등급
SELECT DEPTNO, ENAME, SAL, GRADE
FROM EMP, SALGRADE
WHERE LOSAL <= SAL AND SAL <= HISAL; 

--19 사원번호, 사원명, 부서번호, 부서명, 등급
-- SELECT의 EMP.DEPTNO는 DEPT.DEPTNO써도 상관 없음. 둘 다 해당되기 때문에.
SELECT EMPNO, ENAME, EMP.DEPTNO, DNAME, GRADE
FROM EMP, DEPT, SALGRADE
WHERE EMP.DEPTNO = DEPT.DEPTNO 
AND SALGRADE.LOSAL <= EMP.SAL
AND EMP.SAL <= SALGRADE.HISAL;

--20 사원의 정보와 그 사원에 대한 부서정보를 사원번호 순으로 검색
--SELECT E.*, D.*라고 써도 가능하나, 그럴필요 없음
SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY E.EMPNO;

--21 사원번호, 사원명, 부서번호, 부서명, 위치를 부서번호, 사원번호 순으로 검색
SELECT EMPNO, ENAME, EMP.DEPTNO, DNAME, LOC
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY DEPTNO, EMP.EMPNO;

--22 급여가 3000이상인 사원들의 사원번호, 사원명, 봉급, 부서번호, 부서명 위치
SELECT EMPNO, ENAME, EMP.SAL, EMP.DEPTNO, DNAME, LOC
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND SAL >= 3000;

--23 모든 사원들의 정보와 급여 등급정보(SALGRADE의 모든 정보)를 출력
SELECT *
FROM EMP, SALGRADE
WHERE SALGRADE.LOSAL<=EMP.SAL AND EMP.SAL<=SALGRADE.HISAL;

--24 사원들의 사원번호, 사원명, 관리자번호
SELECT EMPNO, ENAME, MGR
FROM EMP;

--25 사원들의 사원번호, 사원명, 관리자번호, 관리자이름
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS "관리자명"
FROM EMP E1, EMP E2
WHERE E1.MGR=E2.EMPNO;

--26 사원번호, 이름, 관리자 번호, 관리자의 사원번호(MGR_MPTNO), 관리자의 이름(MGR_ENAME)을
--사원번호 순으로 출력 단, 관리자가 없는 사원도 나오게!
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_MPTNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);
--왼쪽 기준. 오른쪽에 짝이 없으면 (+)해서 짝을 맞춰준다.(LEFT OUTER JOIN)

--27
SELECT E1.EMPNO, E1.ENAME, E1.MGR, 
      E2.EMPNO AS MGR_EMPNO,
      E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO
ORDER BY E1.EMPNO;
--오른쪽 기준. 짝이 없으면 NULL로 채워주기

--28 사원번호, 사원명, 직급, 관리자번호, 입사일, 급여, 보너스, 부서번호, 부서명, 위치를 
--부서번호, 사원번호 순으로 정렬(FROM EMP E NATURAL JOIN DEPT D)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;

--29 사원번호, 사원명, 직급, 관리자번호, 입사일, 급여, 보너스, 부서번호, 부서명, 위치를 
--부서번호, 사원번호 순으로 정렬(FROM EMP E JOIN DEPT D USING(DEPTNO))
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;

--30 FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;


--Q1 급여(SAL)가 2000초과인 사원들의 부서 정보, 사원정보를 오른쪽과 같이 출력해보세요. SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL > 2000;
ORDER BY DEPTNO, EMP.EMPNO;

-- SQL-99방식
SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
  FROM EMP E NATURAL JOIN DEPT D
 WHERE E.SAL > 2000;

--Q2 오른쪽과 같이 각 부서별 평균 급여, 최대 급여, 최소 급여, 사원수를 출력해보세요. SQL-99 이전 방식
SELECT D.DEPTNO,
       D.DNAME,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;

--SQL-99 방식
SELECT DEPTNO,
       D.DNAME,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D USING (DEPTNO)
GROUP BY DEPTNO, D.DNAME;

--Q3 모든 부서 정보과 사원 정보를 오른쪽과 같이 부서번호, 사원 이름 순으로 정렬하여 출력해보세요. SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E, DEPT D
 WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY D.DEPTNO, E.ENAME;

--SQL-99 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E RIGHT OUTER JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
ORDER BY D.DEPTNO, E.ENAME;

--Q4 다음과 같이 모든 부서 정보, 사원 정보, 급여 등급 정보, 각 사원의 직속 상관의 정보를 
--부서 번호, 사원 번호 순서로 정렬하여 출력해 보세요. SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME,
       E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO,
       S.LOSAL, S.HISAL, S.GRADE,
       E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
  FROM EMP E, DEPT D, SALGRADE S, EMP E2
 WHERE E.DEPTNO(+) = D.DEPTNO
   AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
   AND E.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO, E.EMPNO; 

--SQL-99방식
SELECT D.DEPTNO, D.DNAME,
       E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO,
       S.LOSAL, S.HISAL, S.GRADE,
       E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
  FROM EMP E RIGHT OUTER JOIN DEPT D
                ON (E.DEPTNO = D.DEPTNO)
              LEFT OUTER JOIN SALGRADE S
                ON (E.SAL BETWEEN S.LOSAL AND S.HISAL)
              LEFT OUTER JOIN EMP E2
                ON (E.MGR = E2.EMPNO)
ORDER BY D.DEPTNO, E.EMPNO; 


----=========6/23===========----

--1. EMP,DEPT 테이블 정보 전부(모두) 보여주기
SELECT *
FROM EMP,DEPT;
--중복이 나온다.(56)

--2 1이 중복 안나오려면?
SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO;
--(14)

--3 2번 부서번호 순으로
SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO
ORDER BY D.DEPTNO;
--ORDER BY DEPTNO만 붙이면 오류가 난다. 어느 소속인지 정해주기

--4 3번 내용을 사원번호,사원명, 부서명
SELECT EMPNO, ENAME, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO
ORDER BY E.DEPTNO;

--5 사원명, 봉급, 등급(SALGRADE.GRADE)
SELECT E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

--6 5와 동일하나, 급여가 2000~3000 사이
SELECT E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
  AND E.SAL BETWEEN 2000 AND 3000;
  
--7 사원명, 부서위치, 급여등급을 부서 및 등급순
SELECT E.ENAME, D.LOC, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY E.DEPTNO, S.GRADE;

--8 사원번호, 사원명, 관리자번호
SELECT EMPNO, ENAME, MGR
FROM EMP;

--9 8번에 관리자명(사원번호, 사원명, 관리자번호, 관리자명)
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 관리자명
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

--10 9번에 부서명까지 추가(사원번호, 사원명, 관리자번호, 관리자명, 부서명)
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 관리자명, D.DNAME
FROM EMP E1, EMP E2, DEPT D
WHERE E1.MGR = E2.EMPNO
AND E1.DEPTNO = D.DEPTNO;

--11 9번문제(사원번호, 사원명, 관리자번호, 관리자명)에 관리자가 없더라도 다 나오게.
--생각해보기
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 관리자명
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);
--E1이 기준. 자기를 관리하는 상사가 없으니 오른쪽에 NULL값 발생.

--12 
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 관리자명
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;
--E2가 기준. 자기 후임이 없으니 왼쪽에 NULL값 발생.

--13
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;
--DEPTNO의 소속을 밝히지 않아도 공용으로 쓰임(NATURAL JOIN이라 가능)

--14 13번에 WHERE절로 바꾸기
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, E.EMPNO;
--DEPTNO의 소속을 밝혀야 한다.

--15 JOIN USING()을 사용해 13번 풀기 "EMP E JOIN DEPT D USING(DEPTNO)"
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D USING(DEPTNO)
ORDER BY DEPTNO, E.EMPNO;
--DEPTNO의 소속을 밝히지 않아도 된다.

--16 EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
ORDER BY D.DEPTNO, E.EMPNO;
--DEPTNO의 소속을 밝혀준다.

--17 11번 다른 방법
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 관리자명
FROM EMP E1 LEFT OUTER JOIN EMP E2
ON(E1.MGR = E2.EMPNO);

--18 12번 다른 방법
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 관리자명
FROM EMP E1 RIGHT OUTER JOIN EMP E2
ON(E1.MGR = E2.EMPNO);

--19 11번,12번 다(전부,모두) 나오게
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 관리자명
FROM EMP E1 FULL OUTER JOIN EMP E2
ON(E1.MGR = E2.EMPNO);

-------------9장. SQL문 속 또 다른 SQL문, 서브쿼리-------------

--부서번호가 10, 20번인 사람
SELECT *
FROM EMP
WHERE DEPTNO=10 OR DEPTNO=20;
--DEPTNO IN(10,20)를 써도 된다.

--1 이름이 JONES인 사람
SELECT * 
FROM EMP
WHERE ENAME='JONES';
--소문자로 입력하면 출력이 되지 않는다. 대문자로 입력했기 때문에.

--1-1 1번 문제. 소문자로 입력했을 경우 출력 방법.
SELECT * 
FROM EMP
WHERE UPPER(ENAME)=UPPER('jones');

--2 급여가 2975이상(>=), 초과(>), 이하(<=), 미만(<)
SELECT *
FROM EMP
WHERE SAL >= 2975;

--3 JONES보다 더 많이 버는 사람(더 많은 봉급을 받는 사람 정보)
SELECT *
FROM EMP
WHERE SAL > (SELECT SAL
              FROM EMP
              WHERE ENAME='JONES');

--4 SCOTT보다 먼저 입사한 사람
SELECT ENAME, HIREDATE
FROM EMP
WHERE HIREDATE < (SELECT HIREDATE
                  FROM EMP
                  WHERE ENAME = 'SCOTT');
                  
--5 급여 평균
SELECT AVG(SAL)
FROM EMP;

--6 급여 평균보다 더 많은 급여 받는 사원정보
SELECT *
FROM EMP
WHERE SAL > (SELECT AVG(SAL)
              FROM EMP);
              
--7 6번에 20번 부서 사원만 사원명, 급여, 부서명 추가
SELECT ENAME, SAL, DNAME, D.DEPTNO
FROM EMP E,DEPT D
WHERE E.DEPTNO = D.DEPTNO 
      AND E.DEPTNO=20
      AND SAL > (SELECT AVG(SAL)
              FROM EMP);
              
--8 부서번호가 10, 20인 사원의 정보
SELECT *
FROM EMP
WHERE DEPTNO=10 OR DEPTNO=20;

--8-1 다른방법
SELECT *
FROM EMP
WHERE DEPTNO IN(10,20);

--9 8번이 아닌 사원의 정보
SELECT *
FROM EMP
WHERE NOT(DEPTNO=10 OR DEPTNO=20);

--9-1 다른 방법
SELECT *
FROM EMP
WHERE DEPTNO NOT IN(10,20);

--10 각 부서별 최고봉급
SELECT MAX(SAL)
FROM EMP
GROUP BY DEPTNO;

--11 각 부서별 최고 급여와 같은 급여 받는 사원정보
SELECT *
FROM EMP
WHERE SAL IN (SELECT MAX(SAL)
              FROM EMP
              GROUP BY DEPTNO);
              
--12
SELECT *
FROM EMP
WHERE (DEPTNO,SAL) IN (SELECT DEPTNO,MAX(SAL)
                       FROM EMP
                       GROUP BY DEPTNO);
                       
----------===== 6/30 =====-----------

-- 1.전 직원의 급여 총계(합계)
SELECT SUM(SAL)
FROM EMP;

-- 2.부서별 총 급여
SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

-- 3. 전체 직원 급여 평균
SELECT AVG(SAL)
FROM EMP;

-- 4.부서별 평균 급여
SELECT DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

--5.부서별 최대 급여
SELECT DEPTNO, MAX(SAL)
FROM EMP
GROUP BY DEPTNO;

--6 부서별 최대 급여와 같은 급여를 받는 사원들의 정보
SELECT *
FROM EMP
WHERE SAL IN (SELECT MAX(SAL)
              FROM EMP
              GROUP BY DEPTNO);

--6-1 6의 다른방법. =ANY를 써도 된다.            
SELECT *
FROM EMP
WHERE SAL =ANY (SELECT MAX(SAL)
                FROM EMP
                GROUP BY DEPTNO);

--6-2 6의 다른방법. =ANY와 =SOME은 같이 쓰인다.                
SELECT *
FROM EMP
WHERE SAL =SOME (SELECT MAX(SAL)
                FROM EMP
                GROUP BY DEPTNO);
                
--7 부서번호 가 10,20, 30 인 사원정보
-- WHERE DEPTNO = 30;은 부서번호가 1개일 때 사용한다.
-- 여러개를 찾을 때는 IN 사용.
SELECT * 
FROM EMP
WHERE DEPTNO IN(10,20,30);

--8 부서별 최대 급여와 같은 급여를 받는 사원들의 정보
SELECT *
FROM EMP
WHERE (DEPTNO,SAL) IN (SELECT DEPTNO,MAX(SAL)
                       FROM EMP
                       GROUP BY DEPTNO);

--9 30번 부서에 속한 사람들의 급여순, 같은 급여이면 사원번호 순으로 정렬해서 급여와 사원번호 출력.
SELECT SAL, EMPNO
FROM EMP
WHERE DEPTNO = 30
ORDER BY SAL, EMPNO;

--9-1 9번의 내림차순. DESC를 써야한다.
SELECT SAL, EMPNO
FROM EMP
WHERE DEPTNO = 30
ORDER BY SAL DESC, EMPNO;

--10 30번 부서에 속한 어떤 사원들의 급여보다 작은 급여를 받는 사원들의 정보
SELECT *
FROM EMP
WHERE SAL <SOME (SELECT SAL
                FROM EMP
                WHERE DEPTNO = 30);
                
--10-1 30번 부서에 속한 어떤 사원들의 급여보다 작은 급여를 받는 사원들의 정보, 급여순, 사원번호순
SELECT *
FROM EMP
WHERE SAL <SOME (SELECT SAL
                FROM EMP
                WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

--10-1-2 10-1의 다른 방법. <ANY. SOME,ANY보다 작은 것.즉, MAX인 2850보다 작은 것.
SELECT *
FROM EMP
WHERE SAL <ANY (SELECT SAL
                FROM EMP
                WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

--10-1-3 10-1의 다른 방법
SELECT *
FROM EMP
WHERE SAL < (SELECT MAX(SAL)
            FROM EMP
            WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

--11 MIN보다 작은 것. 보든 것 보다 작아야 하니까 가장 작아야 한다.
SELECT *
FROM EMP
WHERE SAL <ALL (SELECT SAL
                FROM EMP
                WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

--11-1 11의 다른방법
SELECT *
FROM EMP
WHERE SAL < (SELECT MIN(SAL)
                FROM EMP
                WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

--12 10번 부서에 사원이 존재하면 모든 사원들의 정보 출력 EXISTS존재하면~
SELECT *
FROM EMP
WHERE EXISTS(SELECT EMPNO
             FROM EMP
             WHERE DEPTNO = 10);

--13 50번 부서에 사원이 존재하면 모든 사원들의 정보 출력. 50번 부서가 존재하지 않아 출력되지 않았다.
SELECT *
FROM EMP
WHERE EXISTS(SELECT EMPNO
             FROM EMP
             WHERE DEPTNO = 50);
             
--14 사원들의 사번, 이름, 부서번호, 부서명, 위치
SELECT EMPNO, ENAME, E.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

--15 10번 부서 사원들의 사번, 이름, 부서번호, 부서명, 위치
SELECT EMPNO, ENAME, E.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO AND E.DEPTNO = 10;

--16 사원번호, 사원명, 부서번호, 부서명, 위치 단, 10번 부서에 소속된 사람만, INLINE VIEW 이용
-- 다중열 서브쿼리(MULTI-COLUMN CUBQUERY)는 서브쿼리의 SELECT절에 비교할 데이터를 여러개 지정하는 방식.
-- FROM절에 사용하는 서브쿼리는 인라인 뷰(INLINE VIEW)라고도 부른다.
-- INLINE VIEW(인라인 뷰)는 FROM절에 직접 테이블 명시하여 사용하기에 테이블 내 데이터 규모가 너무 크거나 
--현재 작업에 불필요한 열이 많아 일부만 쓸 때 사용.
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO = 10) E10,
      (SELECT * FROM DEPT) D
WHERE E10.DEPTNO=D.DEPTNO;
      
--17 16번을 WITH절 사용
-- WITH
WITH E10 AS(SELECT * FROM EMP WHERE DEPTNO = 10),
     D AS(SELECT * FROM DEPT)
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM E10, D
WHERE E10.DEPTNO = D.DEPTNO;

--18 사원번호, 이름, 직업, 급여, 급여등급, 부서번호, 부서명
--스칼라부속질의 (SCALAR SUBQUERY)
SELECT EMPNO, ENAME, JOB, SAL, 
(SELECT GRADE 
  FROM SALGRADE 
  WHERE E.SAL BETWEEN LOSAL AND HISAL) 
AS SALGRADE, DEPTNO, 
(SELECT DNAME 
  FROM DEPT
  WHERE E.DEPTNO = DEPT.DEPTNO) 
AS DNAME
FROM EMP E;
--부서 테이블에서 부서명 추출

-- Q0100 내가푼것 전체 사원 중 ALLEN과 같은 직책(JOB)인 사원들의 사원 정보, 부서 정보 출력
SELECT JOB, EMPNO, ENAME, SAL, E.DEPTNO, DNAME
FROM (SELECT * FROM EMP WHERE DEPTNO = 30) E,
      (SELECT * FROM DEPT) D
WHERE E.DEPTNO = D.DEPTNO AND JOB = 'SALESMAN'
ORDER BY SAL DESC; 

-- Q1 답 전체 사원 중 ALLEN과 같은 직책(JOB)인 사원들의 사원 정보, 부서 정보 출력
SELECT E.JOB, E.EMPNO, E.ENAME, E.SAL, E.DEPTNO, D.DNAME
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
   AND JOB = (SELECT JOB
                FROM EMP
               WHERE ENAME = 'ALLEN'); 

-- Q0200 내가푼것 전체 사원의 평균 급여(SAL)보다 높은 급여를 받는 사원들의 사원 정보, 부서 정보, 급여 등급정보를 출력
SELECT DISTINCT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE SAL > (SELECT AVG(SAL)
                  FROM EMP)
AND E.DEPTNO = D.DEPTNO AND
E.SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY SAL DESC;

-- Q2 답 전체 사원의 평균 급여(SAL)보다 높은 급여를 받는 사원들의 사원 정보, 부서 정보, 급여 등급정보를 출력
SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
  FROM EMP E, DEPT D, SALGRADE S
 WHERE E.DEPTNO = D.DEPTNO
   AND E.SAL BETWEEN S.LOSAL AND S.HISAL
   AND SAL > (SELECT AVG(SAL)
                FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO; 

--Q3 10번 부서에 근무하는 사원 중 30번 부서에는 존재하지 않는 직책을 가진 사원들의 사원정보, 부서정보 출력
SELECT E.EMPNO, E.ENAME, E.JOB, E.DEPTNO, D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
   AND E.DEPTNO = 10
   AND JOB NOT IN (SELECT DISTINCT JOB
                     FROM EMP
                    WHERE DEPTNO = 30); 

-- Q4 직책이 SALESMAN인 사람들의 최고 급여보다 높은 급여를 받는 사원들의 사원 정보, 급여 등급 정보를 출력.
--Q4-1 다중행 함수 사용하지 않는 방법
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
  FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
   AND SAL > (SELECT MAX(SAL)
                FROM EMP
               WHERE JOB = 'SALESMAN')
ORDER BY E.EMPNO; 

--Q4-2 다중행 함수 사용하는 방법
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
  FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
   AND SAL > ALL (SELECT DISTINCT SAL
                    FROM EMP
                   WHERE JOB = 'SALESMAN')
ORDER BY E.EMPNO; 

-- 19
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

----------====7/7====----------
--10장. 데이터를 추가, 수정, 삭제하는 데이터 조작어

--1. 테이블 생성
CREATE TABLE DEPT_TEMP
AS SELECT*FROM DEPT;
--Table DEPT_TEMP이(가) 생성되었습니다.

--2. 내용 확인
SELECT * 
FROM DEPT_TEMP;

--3 50, DATABASE, SEOUL 입력
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (50, 'DATABASE', 'SEOUL');
-----1 행 이(가) 삽입되었습니다.

SELECT *
FROM DEPT_TEMP;

--4 60, NETWORK, BUSAN
INSERT INTO DEPT_TEMP
VALUES ( 60, 'NETWORK', 'BUSAN');

--5 70, WEB, LOC는 지정하지 않는다.(값: NULL)
INSERT INTO DEPT_TEMP
VALUES ( 70, 'WEB', NULL);

--6 80, MOBILE,''
INSERT INTO DEPT_TEMP
VALUES ( 80,'MOBILE', '');
--NULL과 '', (빈칸) 모두 같다.

--7 90 INCHEON--LOC
INSERT INTO DEPT_TEMP (DEPTNO, LOC)
VALUES ( 90, 'INCHEON');

--8 테이블 이름: EMP_TEMP 조건 EMP테이블에서 값은 가져오지 않고 테이블 생성(WHERE 1<>1)
CREATE TABLE EMP_TEMP
AS SELECT * FROM EMP
WHERE 1<>1;

SELECT * 
FROM EMP_TEMP;

--9 사원번호:999, 홍길동, PRESIDENT, NULL, 2001/01/01, 5000, 1000, 10 입력
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (999, '홍길동', 'PRESIDENT', NULL, '2001/01/01', 5000, 1000, 10);

SELECT * 
FROM EMP_TEMP;

--10 2111, 이순신, MANAGER, 9999, 07/01/2001, 4000, NULL, 20
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (2111,'이순신', 'MANAGER', 9999, '2001/07/01', 4000, NULL, 20);

--11 10-1 다른 방법. TO_DATE를 사용하면 양식이 달라도 입력이 가능하다.
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (2111,'이순신', 'MANAGER', 9999, TO_DATE('07/01/2001''DD/MM/YYYY'), 4000, NULL, 20);

--12 3111, 심청이, MANAGER, 9999, SYSDATE, 4000, NULL, 30
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (3111, '심청이', 'MANAGER', 9999, SYSDATE, 4000, NULL, 30);
--SYSDATE 오늘날짜

--13 EMP테이블과 SALGRADE테이블을 이용해서 GRADE가 1인 사원들의 정보만 EMP_TEMP테이블에
--EMPNO, ENAME, JOB, MGR, HIREDATE, DAL, COMM, DEPTNO 입력
INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
  SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
    FROM EMP E, SALGRADE S
  WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
    AND S.GRADE = 1;
-- GRADE가(등급이) 1인 사원들의 정보가 들어가야 한다. S.GRADE = 1

SELECT * FROM EMP_TEMP;

--14 DEPT테이블의 내용을 복사해서 DEPT_TEM2 테이블 생성
CREATE TABLE DEPT_TEMP2
  AS SELECT*FROM DEPT;
  
SELECT * FROM DEPT_TEMP2;

--15 DEPT2테이블에서 LOC는 전부 SEOUL로 수정
UPDATE DEPT_TEMP2
  SET LOC ='SEOUL';
  
--16 ROLLBACK; 데이터 조작어들 되돌리기
ROLLBACK;

--17 DEPT_TEMP2 에서 부서번호:40 부서명:DATABASE, 주소:SEOUL 변경
UPDATE DEPT_TEMP2
  SET DNAME = 'DATABASE', DEPTNO = 40, LOC = 'SEOUL'
  WHERE DEPTNO = 40;
  
SELECT * FROM DEPT_TEMP2;

--18 DEPT테이블에서 부서:40 부서이름, 주소 가져와서 EMP_TEMP2테이블의 40번 부서의 부서명과 주소를 변경
UPDATE DEPT_TEMP2
  SET (DNAME, LOC) = (SELECT DNAME, LOC 
                      FROM DEPT 
                      WHERE DEPTNO = 40)
  WHERE DEPTNO = 40;
-- 가져와서 변경. '=' 사용

SELECT * FROM DEPT_TEMP2;

--19 18번의 다른 방법. 따로 분류했다.
UPDATE DEPT_TEMP2
  SET DNAME = (SELECT DNAME 
                      FROM DEPT 
                      WHERE DEPTNO = 40),
      LOC = (SELECT LOC 
                      FROM DEPT 
                      WHERE DEPTNO = 40)
  WHERE DEPTNO = 40;
  
SELECT * FROM DEPT_TEMP2;

--수정, 변경은 UPDATE  
--20 DEPT_TEMP2 의 부서명이 OPERATIONS인 부서의 부서번호와 같은 부서의 주소를 SEOUL로 수정
UPDATE DEPT_TEMP2 
  SET LOC = 'SEOUL'
  WHERE DEPTNO = (SELECT DEPTNO FROM DEPT_TEMP2
                  WHERE DNAME = 'OPERATIONS');
  
SELECT * FROM DEPT_TEMP2;
  
--21 EMP테이블의 내용을 가져와서 EMP_TEMP2테이블을 생성
CREATE TABLE EMP_TEMP2
  AS SELECT * FROM EMP;

SELECT * FROM EMP_TEMP2;

--22 EMP_TEMP2의 테이블 내용 중 JOB이 MANAGER인 사원정보 삭제
DELETE FROM EMP_TEMP2
 WHERE JOB = 'MANAGER';

SELECT * FROM EMP_TEMP2;

--23 EMP_TEMP2테이블에서 3등급(GRADE)이고 부서번호가 30번인 부서의 사원부서와 같은 사원들의 삭제
DELETE FROM EMP_TEMP2
  WHERE EMPNO IN (SELECT EMPNO 
                  FROM EMP_TEMP2 E, SALGRADE S 
                  WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
                  AND S.GRADE = 3 
                  AND E.DEPTNO = 30);
  
SELECT * FROM EMP_TEMP2;
  
--24 EMP_TEMP2테이블 삭제
DELETE FROM EMP_TEMP2;
  
SELECT * FROM EMP_TEMP2;

--Q 테이블 생성
CREATE TABLE CHAP10HW_EMP AS SELECT * FROM EMP;
  SELECT * FROM CHAP10HW_EMP;
  
CREATE TABLE CHAP10HW_DEPT AS SELECT * FROM DEPT;
  SELECT * FROM CHAP10HW_DEPT;

CREATE TABLE CHAP10HW_SALGRADE AS SELECT * FROM SALGRADE;
  SELECT * FROM CHAP10HW_SALGRADE;

--Q1 CHAP10HW_DEPT 테이블에 50,60,70,80번 부서 를 등록
INSERT INTO CHAP10HW_DEPT
   VALUES(50, 'ORACLE','BUSAN');

INSERT INTO CHAP10HW_DEPT
   VALUES(60, 'SQL','ILSAN');

INSERT INTO CHAP10HW_DEPT
   VALUES(70, 'SELECT','INCHEON');

INSERT INTO CHAP10HW_DEPT
   VALUES(80, 'DML','BUNDANG');
   
SELECT DEPTNO, DNAME, LOC 
FROM CHAP10HW_DEPT;
   
--Q2. CHAP10HW_EMP테이블에 다음 8명의 사원 정보를 등록 (이따 다시)
--CREATE TABLE CHAP10HW_EMP 
INSERT INTO CHAP10HW_EMP
VALUES(7201, 'TEST_USER1', 'MANAGER', 7788, TO_DATE('2016-01-02', 'YYYY-MM-DD'), 4500, NULL, 50);
INSERT INTO CHAP10HW_EMP
VALUES(7202, 'TEST_USER2', 'CLERK', 7201, TO_DATE('2016-02-21', 'YYYY-MM-DD'), 1800, NULL, 50);
INSERT INTO CHAP10HW_EMP
VALUES(7203, 'TEST_USER3', 'ANALYST', 7201, TO_DATE('2016-04-11', 'YYYY-MM-DD'), 3400, NULL, 60);
INSERT INTO CHAP10HW_EMP
VALUES(7204, 'TEST_USER4', 'SALESMAN', 7201, TO_DATE('2016-05-31', 'YYYY-MM-DD'), 2700, 300, 60);
INSERT INTO CHAP10HW_EMP
VALUES(7205, 'TEST_USER5', 'CLERK', 7201, TO_DATE('2016-07-20', 'YYYY-MM-DD'), 2600, NULL, 70);
INSERT INTO CHAP10HW_EMP
VALUES(7206, 'TEST_USER6', 'CLERK', 7201, TO_DATE('2016-09-08', 'YYYY-MM-DD'), 2600, NULL, 70);
INSERT INTO CHAP10HW_EMP
VALUES(7207, 'TEST_USER7', 'LECTURER', 7201, TO_DATE('2016-10-28', 'YYYY-MM-DD'), 2300, NULL, 80);
INSERT INTO CHAP10HW_EMP
VALUES(7208, 'TEST_USER8', 'STUDENT', 7201, TO_DATE('2018-03-09', 'YYYY-MM-DD'), 1200, NULL, 80);


SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO
FROM CHAP10HW_EMP;

--Q3 CHAP10HW_EMP에 속한 사원 중 50번 부서에서 근무하는 사원들의 평균 급여보다 많은 급여를 받고 있는 사원들을 70번 부서로 옮기기
UPDATE CHAP10HW_EMP
SET DEPTNO = 70
WHERE SAL > (SELECT AVG(SAL)
              FROM CHAP10HW_EMP
              WHERE DEPTNO = 50);
              
SELECT * FROM CHAP10HW_EMP;
   
--Q4 
UPDATE CHAP10HW_EMP
SET SAL = SAL*1.1, DEPTNO = 80
WHERE HIREDATE > (SELECT MIN(HIREDATE)
                  FROM CHAP10HW_EMP
                  WHERE DEPTNO = 60);
                  
--Q5 CHAP10HW_EMP에 속한 사원 중, 급여 등급이 5인 사원을 삭제
DELETE FROM CHAP10HW_EMP
WHERE EMPNO IN(SELECT EMPNO
              FROM CHAP10HW_EMP E,
                  CHAP10HW_SALGRADE S
              WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
              AND S.GRADE = 5);
              
SELECT * FROM CHAP10HW_EMP;
   
--**DEPT_TEMP 테이블에서 6,8,10,12번 지우기(생성하다가 중복됨)  
SELECT * FROM DEPT_TEMP;

DROP TABLE DEPT_TEMP
WHERE DEPTNO = 60, DNAME= 'DATABASE';